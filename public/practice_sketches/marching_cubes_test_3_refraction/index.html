<!DOCTYPE html>
<html lang="en">
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <script src="https://cdn.rawgit.com/mrdoob/stats.js/r17/build/stats.min.js"></script>
    <script src="edge_indices.js"></script>
    <script src="triangulation_table.js"></script>
    <script src="perlin.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.3.1/p5.min.js"></script>
    <script id="vert" type="x-shader/x-vertex">
      // wouldn't have been possible without the following link:
      // https://tympanus.net/codrops/2019/10/29/real-time-multiside-refraction-in-three-steps/

      uniform float time;
      
      varying vec2 vUv; // uv coordinates of each pixel
      varying vec3 norm;
      varying vec3 eyeVector;
      varying vec3 worldNormal;
      
      void main()
      {
          vUv = uv;
          norm = normalize(normal);
          vec3 posChanged = position;

          vec4 worldPosition = modelMatrix * vec4(position, 1.0);
          eyeVector = normalize(worldPosition.xyz - cameraPosition);
          worldNormal = normalize(modelViewMatrix * vec4(normal, 0.0)).xyz;
         
          
          gl_Position = projectionMatrix * modelViewMatrix * vec4(posChanged,1.0);
      }

  </script>

  <script id="frag" type="x-shader/x-fragment">
      // wouldn't have been possible without the following link:
      // https://tympanus.net/codrops/2019/10/29/real-time-multiside-refraction-in-three-steps/

      precision highp float;
      uniform float time;
      uniform vec2 resolution;
      uniform sampler2D tex;

      varying vec2 vUv;
      varying vec3 norm;
      varying vec3 eyeVector;
      varying vec3 worldNormal;

      float fresnel(vec3 eyeVector, vec3 worldNormal){
        return  pow(1.0 + dot(eyeVector, worldNormal), 2.0); 
      }

      vec2 pc(vec2 d){
        return (gl_FragCoord.xy - d) / resolution.xy;
      }

      void main(void) 
      {
        vec2 uv = vUv;
        vec2 sc = gl_FragCoord.xy / resolution; // screen coordinates
        vec3 n = worldNormal;
        vec3 refracted = refract(eyeVector, n, 1.0 / 0.89);
        vec4 texcopy = texture2D(tex, sc); // texture before refraction


        
        

        sc += refracted.xy  * 0.25;
        uv += refracted.xy;

        vec4 t =  texture2D(tex, sc);

        

        

        float f = fresnel(eyeVector, n);


        vec3 outCol = t.rgb;

        float cbd = 2.0; // chromatic aberration dist

        vec4 rt = texture2D(tex, pc(vec2(cbd, .0)) + refracted.xy * 0.25);
        if (rt.r > 0.5) outCol.r += 1.0;

        vec4 gt = texture2D(tex, pc(vec2(.0, cbd)) + refracted.xy * 0.25);
        if (gt.g > 0.5) outCol.g += 1.0;

        vec4 bt = texture2D(tex, pc(vec2(-cbd, -cbd)) + refracted.xy * 0.25);
        if (bt.b > 0.5) outCol.b += 1.0;
        
        
        outCol = mix(outCol, vec3(1.0), f);

        gl_FragColor = vec4(outCol, 1.0);
      }

      


  </script>
    <link rel="stylesheet" type="text/css" href="style.css">
    <meta charset="utf-8" />

  </head>
  <script type="module" src="main.js"></script>
  <body>
    <canvas id="c"></canvas>
  </body>
</html>